import pandas as pd

# Sample data as a pandas DataFrame
data = {
    'Job Level': [[3.0, 2.0, 4.0, 1.0, 3.0],
                  [float('nan'), 1.0, 3.0, 2.0, 4.0],
                  [2.0, 3.0, 1.0, 4.0, 3.0]],
    'Organization': [['Marketing', 'Finance', 'HR', 'IT', 'Marketing'],
                     ['HR', 'Marketing', 'Finance', 'IT', 'HR'],
                     ['Finance', 'HR', 'Marketing', 'IT', 'Finance']],
    'Employee ID': [['EMP001', 'EMP002', 'EMP003', 'EMP004', 'EMP005'],
                    ['EMP006', 'EMP007', 'EMP008', 'EMP009', 'EMP010'],
                    ['EMP011', 'EMP012', 'EMP013', 'EMP014', 'EMP015']],
    'Meeting ID': [1, 1, 2, 2, 3],
    'Meeting Date': ['2024-04-28', '2024-04-28', '2024-04-29', '2024-04-29', '2024-04-30']
}

df = pd.DataFrame(data)

# Function to count the number of times each person was the most senior member in his organization for each meeting ID and date
def count_most_senior_in_organization(df):
    senior_count_by_meeting = {}
    senior_count_overall = {}
    total_meetings_attended = {}
    max_levels = {}
    
    for idx, row in df.iterrows():
        job_levels = row['Job Level']
        organizations = row['Organization']
        employee_ids = row['Employee ID']
        meeting_id = row['Meeting ID']
        meeting_date = row['Meeting Date']
        
        for level, org, emp in zip(job_levels, organizations, employee_ids):
            total_meetings_attended[emp] = total_meetings_attended.get(emp, 0) + 1
            
            if (meeting_id, meeting_date) not in max_levels:
                max_levels[(meeting_id, meeting_date)] = {}
                senior_count_by_meeting[(meeting_id, meeting_date)] = defaultdict(int)
                
            if org not in max_levels[(meeting_id, meeting_date)] or level > max_levels[(meeting_id, meeting_date)][org]:
                max_levels[(meeting_id, meeting_date)][org] = level
                senior_count_by_meeting[(meeting_id, meeting_date)][emp] = 1
                senior_count_overall[emp] = senior_count_overall.get(emp, 0) + 1
            elif level == max_levels[(meeting_id, meeting_date)][org]:
                senior_count_by_meeting[(meeting_id, meeting_date)][emp] += 1
                senior_count_overall[emp] = senior_count_overall.get(emp, 0) + 1
                
    return senior_count_by_meeting, senior_count_overall, total_meetings_attended

# Count the number of times each person was the most senior member in his organization for each meeting ID and date, overall, and total meetings attended
senior_count_by_meeting, senior_count_overall, total_meetings_attended = count_most_senior_in_organization(df)

# Print the counts for each meeting ID and date
print("Senior count by meeting ID and date:")
for (meeting_id, meeting_date), count in senior_count_by_meeting.items():
    print(f"Meeting ID: {meeting_id}, Date: {meeting_date}, Senior count: {count}")

# Print the overall counts
print("\nOverall senior count:")
for emp, count in senior_count_overall.items():
    print(f"Employee ID: {emp}, Overall senior count: {count}")

# Print the total meetings attended by each person
print("\nTotal meetings attended:")
for emp, count in total_meetings_attended.items():
    print(f"Employee ID: {emp}, Total meetings attended: {count}")

# Calculate and print the ratio of being the most senior member in the organization to the total number of meetings attended
print("\nRatio of being the most senior member in the organization to total meetings attended:")
for emp in senior_count_overall.keys():
    ratio = senior_count_overall[emp] / total_meetings_attended[emp]
    print(f"Employee ID: {emp}, Ratio: {ratio:.2f}")
import pandas as pd

# Load the data into a DataFrame
df = pd.read_csv('employee_performance.csv')

# Convert end_of_month_date to datetime
df['end_of_month_date'] = pd.to_datetime(df['end_of_month_date'])

# Sort the DataFrame by employee_id and end_of_month_date
df = df.sort_values(by=['employee_id', 'end_of_month_date'])

# Create a new column to indicate if the performance was 'Below Strong'
df['below_strong'] = df['performance_category'].apply(lambda x: 1 if x == 'Below Strong' else 0)

# Define a function to calculate the rolling count of below strong ratings in the past N days
def rolling_below_strong_count(df, days):
    return df.groupby('employee_id').apply(
        lambda x: x.set_index('end_of_month_date')['below_strong']
                   .rolling(f'{days}D').sum().reset_index(drop=True)
    ).reset_index(drop=True)

# Calculate the rolling count for the past 6 months (approx. 180 days) and 12 months (approx. 365 days)
df['below_strong_last_6_months'] = rolling_below_strong_count(df, 180)
df['below_strong_last_12_months'] = rolling_below_strong_count(df, 365)

# Function to calculate the months since first 'Below Strong' rating
def months_since_first_below_strong(df):
    first_below_strong_dates = df[df['below_strong'] == 1].groupby('employee_id')['end_of_month_date'].min()
    df = df.merge(first_below_strong_dates.rename('first_below_strong_date'), on='employee_id', how='left')
    df['months_since_first_below_strong'] = df.apply(
        lambda row: (row['end_of_month_date'] - row['first_below_strong_date']).days // 30 
                    if pd.notnull(row['first_below_strong_date']) else None,
        axis=1
    )
    return df

# Apply the function to calculate months since first 'Below Strong' rating
df = months_since_first_below_strong(df)

# Drop the temporary columns used for calculations
df.drop(columns=['below_strong', 'first_below_strong_date'], inplace=True)

# Display the resulting DataFrame
print(df)


def simulate_employee_attrition(employee_id, attrition_risk, num_months=6):
    """Simulate whether an employee attrits each month."""
    attrition_status = []
    for month in range(num_months):
        if np.random.rand() < attrition_risk:
            attrition_status.append(True)
        else:
            attrition_status.append(False)
    return attrition_status

# Apply simulation to each employee
df['Monthly_Attrition'] = df.apply(lambda row: simulate_employee_attrition(row['Employee_ID'], row['Attrition_Risk']), axis=1)

# View results
print(df[['Employee_ID', 'Attrition_Risk', 'Monthly_Attrition']].head())


def simulate_group_attrition(df, num_simulations=1000):
    num_employees = len(df)
    num_months = 6
    results = []

    for _ in range(num_simulations):
        total_attritions = 0
        for index, row in df.iterrows():
            attrition_risk = row['Attrition_Risk']
            attrition_occurred = False
            for month in range(num_months):
                if np.random.rand() < attrition_risk:
                    attrition_occurred = True
                    break
            if attrition_occurred:
                total_attritions += 1
        results.append(total_attritions)

    return results

# Run group attrition simulation
results = simulate_group_attrition(df)

# Analyze results
import matplotlib.pyplot as plt

plt.hist(results, bins=30, edgecolor='k', alpha=0.7)
plt.xlabel('Number of Employees Attriting At Least Once Over 6 Months')
plt.ylabel('Frequency')
plt.title('Monte Carlo Simulation of Employee Attrition (Group Level)')
plt.show()

print(f"Mean attritions over 6 months: {np.mean(results):.2f}")
print(f"Standard deviation of attritions: {np.std(results):.2f}")
print(f"95% confidence interval: {np.percentile(results, [2.5, 97.5])}")
